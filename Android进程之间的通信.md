### Android进程之间的通信
　本节主要学习安卓中的进程间的通信，包括Socket(AMS连接Zygote时使用的就是Socket)和Binder（这个例子就多了）。
#### Binder进程间的通信
> 是什么？有什么用？原理是怎样的？
这篇文章理解得很好了，<a href='http://www.cnblogs.com/angeldevil/p/3296381.html'>链接。</a>    

##### 是什么？  
是一个类、是一种驱动、是进程间的一种通信机制都可以。
##### 有什么用？
当然是实现了进程间的通信。
##### 为什么选用Binder来进程间通信？
**1.传输性能。**socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。  
**2.安全性考虑。**Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。首先传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。  
**3.Client-Server的通信方式，可以Server开发一次，被多个Client使用。** 
 
##### binder实现进程间通信的原理  
Binder框架定义了四个角色：Server，Client，ServiceManager以及Binder驱动。其中Server，Client，SMgr运行于用户空间，驱动运行于内核空间。这四个角色的关系和互联网类似：Server是服务器，Client是客户终端，SMgr是域名服务器（DNS），驱动是路由器。  
当我想要使用XXXService时，首先向SM(ServerManager)查询，名叫XXX的服务是否存在，存在的话SM就会将XXX服务的Binder实体(就是XXX服务的实现端，Server)的引用返回来给我。现在我操作Binder实体的引用(就类似Java的对象的引用)，就自动可以操作远程服务。这个过程具体又是怎么实现的呢？当我调用引用的方法时，胡构建一个binder_transaction_data，在其中code字段填入标识调用方法的编号，handle字段填入Bindler实体地址，然后将数据写入到Binder驱动缓存中。然后Binder驱动通知服务对应的Binder实体读取数据，然后解析据code编号就可以知道调用哪个方法了，调用完之后将返回的数据写入Binder。  




　

